Why write this?
===============

I wrote this when replying to the umpteenth "What language should I learn?"
post.  My posts to that sort of question were inevitably long screeds, so I
wrote this document which will get referenced in any future posts of mine.

Programming is not about the language
-------------------------------------

When I was at university trying to learn how to be a programmer it was clear
that there were three types of students:

1. Those who would never be good even though they studied hard
2. The average students who learnt a bit but were average
3. Those who were going to be good despite being at university

You need to be something like type 3 if you have any hope of learning to be a
programmer by yourself.  How do you become type 3?  I don't know.  Certainly curiosity is part
of a good programmer.  Patience and lack of patience, at the appropriate time,
is another.  `Larry Wall <http://c2.com/cgi/wiki?LazinessImpatienceHubris>`_
has a great quote along these lines.

The type 3 students were the ones who worked late hours trying things out,
trying a different approach or algorithm.  Because there might be a better way.

To learn to be a programmer by yourself you have to become what I call a
"hacker".  The modern definition of the word "hacker" is rather negative.  The
`older definition <http://www.catb.org/jargon/html/H/hacker.html>`_
describes the good programmer personality.  I would add to that definition
the attributes of curiosity and inventiveness.  You should always try for an
acceptable on-time solution but always be thinking about better solutions,
easier long-term maintenance, more adaptable code, etc.

A computer language is just the basic tool used to tell a computer what to do.
You have to know what to do first, before you tell the computer!  And that's
**really** what being a programmer is all about.

Paradigms, database, network, gui, ...
--------------------------------------

There's a lot more to programming than the language you use.  Being able to use
a particular language well is just the very beginning.  If you want to solve
problems (which is really what a computer is used for) then you need to get into
a myriad other things, such as databases, GUI libraries, data structures, etc.
While I don't agree with everything said,
`this overview <http://www.wikihow.com/Become-a-Programmer>`_ might be useful.

There are different paradigms in languages, such as procedural programming,
object-oriented programming, functional programming and logic programming.
There are many other words used, many marketing driven.  You should get exposed
to them all, or at least a large subset.  This is why I like Python for
beginners: it's simple to start but you can get into some really advanced usage
when you are ready.  Ruby is probably like that, but I don't really know.

Operating system
----------------

In the beginning it really doesn't matter what operating system you use.  Later,
though, it's important that you get exposed to the three big OSs: Windows, OSX
and Linux.  OSX and Linux are sort of the same, but Windows is very different.
If you can, start learning on both Windows and Linux.  If you don't want to
spend money, learn on Linux.  You really need Apple hardware to run OSX, but you
don't need to *learn* on OSX, so leave that OS until you need that platform.

Resources
---------

You will use a lot of online resources while learning and when a working
programmer.  So an internet connection is required.  Not necessarily a reliable
connection while *learning*, but when working you need a reliable connection.
`Google <https://www.google.com>`_ is your friend!
Or `DuckDuckGo <https://duckduckgo.com/>`_, etc.

When you get some experience try to help others in your language or framework
of choice.  You don't really know something until you've tried to teach someone
else, and that's when your own learning accelerates!

GitHub
------

While I'm not a great fan of `GitHub <https://github.com/>`_
you should create an account and develop any code you write in it.  For better
or worse it's a good place to show your portfolio of code.  People can look at
the quality and how often you update.  Plus it's a good way to backup your code
and get experience using a distributed version control system and an issues
tracker.  There are other, similar, repositories, but GitHub is the 800 pound
gorilla at the moment.

Broadening experience
---------------------

When you know one language reasonably well you should try another DIFFERENT
language.  Even the best language constrains the way you think about and solve a
problem, so exposing yourself to a very different language helps to broaden your
view.  Languages like C, Python, Java, Forth or even an assembly language are
useful in this respect.  I would even go so far as to recommend installing
Scheme and plowing through the first few chapters of
`SICP <https://mitpress.mit.edu/sicp/>`_.  The
`videos <http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/>`_
are also good value.  You will be exposed to a very different approach to
problem solving.

Side projects
-------------

You won't get anywhere if all you do is follow an online tutorial and do the
exercises.  Even if it's a really good tutorial.  You have to take a solution
(yours, or the tutorial one if one is given) and try to critique the code.  Is
that a good way?  Could it be more readable?  Would a different algorithm be
faster or more clear?  Try to solve a more generalised problem than that given
in the tutorial.  I have found the early
`Google Code Jam <https://code.google.com/codejam>`_ problems to be very good at
making you think and sweat, particularly those that have time and memory
constraints.  There are other sites that have problems you can try.

Even better, after getting your first solution try to solve the exercise again
in a different language.  That's a really good way to learn your second
language!

You must write code to learn to program, and then analyse the code, tear it
apart and rewrite it.  Get your hands dirty.

There is no better way to learn than by solving your own problems.  Have a
problem with iTunes mangling your playlists?  Write some code that creates
playlists the way you want them.  It's time to change passwords for the hundred
or so sites you use?  Write a little program to generate strong memorable
passwords that you will use, with configurable lengths and characters used.
Solving your own personal problems makes your learning more interesting, you
get closer to real-world programming and you get pushed into areas you might
not have been before.

Communication
-------------

It's important that you can communicate freely and well.  Even if you are a
native English speaker you need to work on your presentation.  If you are not
a native speaker then you have to do even more work.

When you work with programming languages you have to be very precise, and this
carries over into the written English language.
`This <http://www.catb.org/esr/faqs/hacker-howto.html#skills4>`_ explains why
good English is important.

For example, I wrote the first draught of this in vim into a text file.  But I
copied it into OpenOffice so I could spell-check it before I committed it.  I
hope that all my mistakes were caught, but probably not.

PS: Alas, after committing I found some grammar errors.  Grammar is hard.

Summary
-------

After all that, I haven't yet answered the original question:

    What language should I learn first?

I hope you can see now that your first language doesn't really matter as you
will go on to learn many others if you become a working programmer.  However,
the way to knowledge can be smoother if you choose a language that doesn't
clutter your path with initially unnecessary complications.  You are really
learning how to solve problems with a computer.  The language is incidental.

Python is a good first language, as is Ruby.  Either of those will help you get
started by teaching you the fundamentals.  If you are going to learn by yourself
look at the support communities for your language of choice, on-line tutorials,
etc.

If you start with another language that's fine.  Just be sure to expose yourself
to other languages later.  If you don't get some exposure to other ideas and
approaches you can get a distorted view of what is possible in any solution you
write.  Paul Graham talked about this in his essay
`Beating the Averages <http://www.paulgraham.com/avg.html>`_ in the section
*The Blub Paradox*.

Good luck!
